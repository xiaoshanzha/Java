## 面向对象技术
[toc]
#### 1.	面向对象和面向过程有什么区别？
```
面向对象：把数据及对数据的操作方法放在一起，作为一个相互依存的整体，即对象。对同类对象抽象出其共性，即类，类通过简单的外部接口与外界发生关系。
面向过程：以事件为中心，自顶向下顺序执行。程序结构按功能划分为若干基本模块， 功能相对独立。
```
```
不同之处：
① ：出发点不同，
面向对象: 用符合常规思维的方式处理客观问题，把问题的要领直接映射到对象及对象的接口上。
面向过程: 强调过程的抽象化和模块化，以过程为中心处理客观问题，

② ：层次逻辑关系不同
面向对象: 用计算机逻辑模拟客观世界的物理存在，处理问题的基本单位是对象的集合类，用类的层次结构体现类之间的继承和发展，
面向过程: 处理问题的基本单位是表达过程的模块，用模块的层次结构概括间的关系和功能。

③ ：数据处理方式和控制程序方式不同
面向对象：将数据与对应的代码封装成一个整体，对象的修改只能由自身的成员函数完成。通过“事件驱动”激活和运行程序。
面向过程：直接通过程序处理数据， 控制程序方式上按照设计调用或返回程序。

④ ：分析设计和编码转换方式不同：
面向对象：从分析到设计再到编码采用一致性的模型表示。是一种平滑过程，
面向过程：强调分析、设计、编码之间按规则进行转换，是一种有缝的连接。
```


-----

#### 2.	面向对象的特征：
```
抽象：忽略与当前目标无关的方面，只选择跟目标有关的进行了解，包括过程和数据抽象。

继承：允许和鼓励类的重用，新类称为原始类的派生类，原始类为新类的基类。派生类可修改或增加新的方法。

封装：将客观事物抽象成类，每个类保护自身的数据和方法。

多态：允许不同类的对象对同一消息做出响应。有灵活、抽象、代码和行为共享优势，很好地解决应用程序函数同名问题。 有参数化多态和包含多态。
```
---

#### 3.	面向对象开发优点：
```
① ：开发效率高 ：可以对现实事物进行抽象，可以通过继承或组合的方式实现代码重用 
② ：保证软件的鲁棒性：面向对象开发有很高的重用性，
③ ：保证软件高可维护性。可读性好，面向对象的设计模式使得代码结构清晰，
```
---

#### 4.	什么是继承？
```
见上2题。
特征：
① ：不支持多继承，但可通过实现多个接口达到多重继承目的。
② ：只能继承父类的非私有(public、protected)成员变量和方法。
③ ：变量同名时，子类中的成员变量覆盖父类的，而不会继承。
④ ：相同的函数签名（相同的方法名，相同的参数个数和类型），子类覆盖父类
```
---

#### 5.	组合和继承的区别：
```
组合：在新类里面创建原有类的对象，重复利用已有类功能。组合中的整体类和继承中的子类对应，局部类和继承中的父类对应，（“has-a”关系）
继承: 根据其他类的实现来定义一个类的实现。(“is - a”关系)

都允许在新类中设置子对象。组合是显式的，继承是隐式的。
都可实现代码的重用，选择原则：
① ：只有当两个类是“is - a”关系才使用继承，因为过多的使用继承会破坏代码的可维护性，父类修改时，会影响所有继承它的子类。
② : 不要为了实现多态而使用继承，如果没有“is-a”关系，可以通过实现接口与组合的方式达到相同目的，会具有更好的可扩展性。(设计模式中的策略模式)
```
---
#### 6.	多态的实现机制是什么？
```
多态表示同一操作作用在不同对象时，会有不同的语义。类中的方法具有多态性，
成员变量没有多态概念。成员变量的值取谁取决于所定义变量的类型。
对于“+”操作，“3 + 4”表示整数相加，“3”+“4”表示字符串的连接

表现方式：
① ：方法的重载。（编译时多态）
同一个类中有多个同名的方法，但有不同的参数个数、类型或顺序。
② ：方法的覆盖（运行时多态）：
子类可以覆盖父类的方法。 程序调用的方法在运行期才动态绑定。
```
---

#### 7.	重载和覆盖的区别：
```
重载：通过不同的参数来区分，不能通过方法的访问权限，返回值类型，抛出异常类型来重载，
      对于继承来说，如果基类方法的访问权限是private,就不能在派生类对其重载，只相当于一个新方法，
覆盖：派生类的覆盖方法与基类要有相同的函数名和参数，返回值要相同，抛出的异常要一致，被覆盖的方法不能为private；

区别：
① ：覆盖是子类和父类的关系 是垂直关系，重载是同一个类中方法之间的关系，水平关系。
② ：覆盖要求参数列表相同，重载要求不同。
③ ：覆盖根据对象类型来决定调用方法体，重载根据参数选择。
④ ：覆盖只能由一个(一对)方法产生关系，重载是多个方法之间的关系。

下图代码会出现编译错误，因为函数不能以返回值来区分，虽然父类和子类函数有不同的返回值，但有相同的函数名，编译器无法区分，
```
![](https://upload-images.jianshu.io/upload_images/10460153-fda58db40bef7b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
---

#### 8.	抽象类和接口的异同：
```
抽象类：类用abstract修饰，含有抽象方法。但也可以拥有成员变量和普通方法，是为了继承而存在的，
       抽象方法必须为public或protected(因为private不能被子类继承)，不能用来创建对象，
       子类必须实现父类的抽象方法，如果没有实现，子类也将定义为abstract类。

接口：含有的变量只能是public static final变量， 方法只能是public abstract方法，
      所有的方法不能有具体的实现，（必须都是抽象方法），一般不定义变量，比抽象类更加抽象。
      非抽象类遵循某个接口后，必须实现接口中所有的方法，抽象类遵循后可以不实现。

相同 ：1.都不能被实例化(因为没有具体实现的方法)
      2.接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才可被实例化。
不同 ：1.接口只有定义，抽象类中抽象方法可以实现。
      2.接口需要实现(implements)，可实现多个，抽象类只能被继承(extends)继承一个,
      3.接口强调特定功能的实现，“has-a”关系，抽象类强调所属关系，“is-a”关系
      4.接口中变量必须public static final，且赋初值，方法只能用public和 abstract修饰。
        抽象类成员变量默认default(本包可见)，也可定义为其他的，可以在子类中被重新定义，
        抽象方法不能用private、static、synchronized、native修饰，
      5. 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象.
         抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

当子类和父类之间有逻辑上的层次关系时，推荐使用抽象类，接口多用于不同类之间，定义不同类之间的通信规则， 
接口可继承接口，抽象类可实现接口，抽象类也可继承具体类。也可以有静态main方法。

Abstract只能修饰类和方法，不能修饰属性。
```
---

#### 9.	内部类有哪些：
```
内部类根据在外部类中的位置分为：成员内部类，局部内部类。

静态内部类：被声明为static的内部类，可以不依赖外部实例化而被实例化，不能与外部类有相同的名字，
           只能访问外部类中的静态成员和静态方法(包括私有)，因为，静态变量和方法随着类的加载而加载，
           而非静态成员是随着对象的生成而生成。所以静态成员或方法的加载时机要早于非静态成员方法或变量的生成。

成员内部类(非静态内部类)：可以自由引用外部类的属性和方法，无论是否非静态.非静态内部类不能有静态成员，
        （java虚拟机要求所有的静态变量必须在对象创建之前完成，类加载的顺序：先加载类，执行static变量初始化，
        接下来执行对象的创建，非静态内部类相当于非静态成员，他的初始化必须在外部类对象创建后执行，
        如果里面有static，则出现矛盾）

局部内部类：定义在一个代码块内(方法中)的类，类似于局部变量，不能被public、protected、pricate以及static修饰，
          只能访问方法中定义为final类型的局部变量，特性跟成员内部类特性基本相同，
          若加上static，则为局部静态内部类，特性跟静态内部类相似。

匿名内部类(特殊的局部内部类)：没有类名，不适用关键字class、extends、implemens，没有构造函数，
        必须继承其他类或实现其他接口，不能定义静态成员和方法、不能被public、protected、pricate以及static修饰，
        实例只能创建一个，所有局内部类限制都有效，使代码更加简洁。（本质是继承该类或实现该接口的匿名对象）。


内部类可以直接访问外部类的成员，包括私有
外部类要访问内部类的成员，必须创建对象

```
![](https://upload-images.jianshu.io/upload_images/10460153-ff8170a0687e90fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

私有成员类不能直接访问，可间接调用。

---
#### 10.	如何获取父类的类名：
```
如果使用super.getClass().getName()方法来获取的话，会出错，因为java中任何类都继承自Object类，
Object类中getClass()方法被定义为final和native，子类不能覆盖该方法，
因此this.getClass()和super.getClass()最终都调用的是Object中的getClass()方法， 
而Object的getClass()方法返回的是此Object的运行时类。

应该通过反射机制，直接使用getClass().getSuperclass().getName()
```
---


#### 11.	this和super的区别：
```
this：用来指向当前实例的对象，用来区分对象的成员变量与方法的形参。

super:用来访问父类的方法或成员变量，且只能通过关键字super。
注意:当子类构造函数需要显示调用父类的构造函数时，super()必须为构造函数中的第一条语句，否则会出现编译错误。
```
---
#### 12.	显隐式调用父类的构造函数
```
java继承中对构造函数是不继承的，只是调用（隐式或显式）。
在创建子类的对象时， Java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法。
在多级继承的情况下，将从继承树的最上层的父类开始，依次执行各个类的构造方法，
这可以保证子类对象从所有直接或间接父类中继承的实例变量都被正确地初始化。 
若父类没有无参的构造函数，则隐式调用失败，必须显式调用有参的构造，
即显式调用了有参构造(eg : super（123）)后系统就不再默认调用无参构造，如果没有任何的构造函数，系统会默认有一个无参的构造函数。
```


